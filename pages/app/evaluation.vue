<script setup lang="ts">
import { computed, watch } from "vue";
import { useRouter, useState } from "#imports";
import type { DmpElement } from "~/server/utils/splitMdByElements";

const router = useRouter();
const currentDmpIndex = useState<number>("dmpIndex");
const overallSatisfaction = ref<number | null>(null);
const overallAuthorshipGuess = ref<string | null>(null);
const overallEvaluationsPerDmp = useState<
  { authorship: string | null; satisfaction: number | null }[]
>("overallEvaluationsPerDmp", () => []);

function saveOverallEvaluation() {
  overallEvaluationsPerDmp.value[dmpIndex.value] = {
    authorship: overallAuthorshipGuess.value,
    satisfaction: overallSatisfaction.value,
  };
}

const toast = useToast();
const dmpState = useState<DmpElement[]>("dmpData");
const dmpIndex = useState<number>("dmpIndex");
const assignedDmps = useState<string[]>("assignedDmps");
const evaluationsPerDmp = useState<any[][][]>("evaluationsPerDmp", () => []);
const evaluations = useState<any[][]>("evaluations", () => []);
const currentPage = useState<number>("currentPage", () => 0);
const participantId = ref<string | null>(null);
const helpTexts = [
  // Page 1: ele1-a, b, c, ele2, ele3
  "Summarize the types and estimated amount of scientific data expected to be generated in the project",
  "Describe which scientific data from the project will be preserved and shared and provide the rationale for this decision",
  "Briefly list the metadata, other relevant data, and any associated documentation (e.g., study protocols and data collection instruments) that will be made accessible to facilitate interpretation of the scientific data",
  "State whether specialized tools, software, and/or code are needed to access or manipulate shared scientific data, and if so, provide the name(s) of the needed tool(s) and software and specify how they can be accessed",
  "State what common data standards will be applied to the scientific data and associated metadata to enable interoperability of datasets and resources, and provide the name(s) of the data standards that will be applied and describe how these data standards will be applied to the scientific data generated by the research proposed in this project.  If applicable, indicate that no consensus standards exist",

  // Page 2: ele4-a, b, c, ele5-a, b, c
  "Provide the name of the repository(ies) where scientific data and metadata arising from the project will be archived; see Selecting a Data Repository",
  "Describe how the scientific data will be findable and identifiable, i.e., via a persistent unique identifier or other standard indexing tools",
  "Describe when the scientific data will be made available to other users (i.e., no later than time of an associated publication or end of the performance period, whichever comes first) and for how long data will be available",
  "Describe and justify any applicable factors or data use limitations affecting subsequent access, distribution, or reuse of scientific data related to informed consent, privacy and confidentiality protections, and any other considerations that may limit the extent of data sharing",
  "State whether access to the scientific data will be controlled (i.e., made available by a data repository only after approval",
  "If generating scientific data derived from humans, describe how the privacy, rights, and confidentiality of human research participants will be protected (e.g., through de-identification, Certificates of Confidentiality, and other protective measures)",

  // Page 3: ele6
  "Describe how compliance with this Plan will be monitored and managed, frequency of oversight, and by whom at your institution (e.g., titles, roles)",
];

watch(currentPage, () => {
  window.scrollTo({ top: 0, behavior: "smooth" });
});

const groupedElements = computed(() => {
  const elements = dmpState.value || [];
  const groups: { title: string; group: DmpElement[] }[] = [];

  for (const el of elements) {
    const existing = groups.find((g) => g.title === el.title);

    if (existing) {
      existing.group.push(el);
    } else {
      groups.push({ title: el.title, group: [el] });
    }
  }

  return groups;
});

const fixedGroups = computed(() => {
  const groups = groupedElements.value;

  // Separate Element 6
  const ele6Index = groups.findIndex((g) =>
    g.title.startsWith("Element 6: Oversight"),
  );

  const ele6 = ele6Index !== -1 ? groups.splice(ele6Index, 1)[0] : null;

  // Now paginate rest in chunks of 3
  const paginated: (typeof groupedElements.value)[] = [];

  for (let i = 0; i < groups.length; i += 3) {
    paginated.push(groups.slice(i, i + 3));
  }

  if (ele6) {
    paginated.push([ele6]); // Page 3: Element 6 alone
  }

  return paginated;
});

const currentElements = computed(
  () => fixedGroups.value[currentPage.value] || [],
);

const scoreOptions = [
  "Very Dissatisfied",
  "Dissatisfied",
  "Neither dissatisfied or satisfied",
  "Satisfied",
  "Very Satisfied",
];
const errorTypes = [
  "Accuracy--Contains incorrect or misleading information, such as mentioning a repository that does not exist",
  "Completeness--Missing something that is required for the Element",
  "Clarity--Uses vague language, such as saying data will be shared but not providing details",
  "Coherence--Information not presented in a logical, organized, and well-connected way",
  "Compliance--Plan would not be in compliance with Funder Policy",
  "Fluency--Contains spelling, punctuation, or grammar issues",
  "Best Practice--Contains plan choices that aren’t recommended",
  "Other--Please mention in comments",
  "None--No errors seen",
];

function createBlankEvaluation(): any[][] {
  return fixedGroups.value.map((group) =>
    group.map(() => ({
      additionalComments: "",
      completenessScore: null,
      otherError: "",
      satisfactionScore: null,
      selectedErrors: [],
      techCorrectScore: null,
    })),
  );
}

watch(
  fixedGroups,
  () => {
    if (!fixedGroups.value.length) return;
    const saved = evaluationsPerDmp.value[dmpIndex.value];

    if (saved) {
      evaluations.value = JSON.parse(JSON.stringify(saved));
    } else {
      evaluations.value = createBlankEvaluation();
      evaluationsPerDmp.value[dmpIndex.value] = JSON.parse(
        JSON.stringify(evaluations.value),
      );
    }
  },
  { immediate: true },
);

watch(
  dmpIndex,
  () => {
    const saved = overallEvaluationsPerDmp.value[dmpIndex.value];

    if (saved) {
      overallSatisfaction.value = saved.satisfaction;
      overallAuthorshipGuess.value = saved.authorship;
    } else {
      overallSatisfaction.value = null;
      overallAuthorshipGuess.value = null;
    }
  },
  { immediate: true },
);

onMounted(() => {
  const pidCookie = useCookie<string | null>("pid");
  participantId.value = pidCookie.value;

  if (!participantId.value) {
    console.error("No PID found in cookie!");
  }
  // If the DMP data is empty, redirect to introduction page
  if (!dmpState.value || !dmpState.value.length) {
    router.replace('/app/introduction'); // replace so back button doesn't go here
  }
});

function saveCurrentEvaluation() {
  evaluationsPerDmp.value[dmpIndex.value] = JSON.parse(
    JSON.stringify(evaluations.value),
  );
}

function validateCurrentPage(): boolean {
  if (currentPage.value < fixedGroups.value.length - 1) {
    for (let groupIndex = 0; groupIndex < currentElements.value.length; groupIndex++) {
      const evalData = evaluations.value[currentPage.value][groupIndex];
      if (!evalData.satisfactionScore || !evalData.selectedErrors?.length) {
        toast.add({
          title: 'Missing Required Fields',
          description: 'Please complete all required fields before continuing.',
          color: 'warning',
        });
        return false;
      }
    }
  } else {
    if (!overallSatisfaction.value || !overallAuthorshipGuess.value) {
      toast.add({
        title: 'Missing Required Fields',
        description: 'Please complete all required fields before continuing.',
        color: 'warning',
      });
      return false;
    }
  }
  return true;
}

function formatContent(content: string) {
  // Replace multiple newlines with a single <br> (for paragraphs)
  // Replace single newlines or newlines with surrounding whitespace with space
  return content
    .replace(/\r/g, "") // remove carriage returns
    .replace(/\n{2,}/g, "<br><br>") // preserve paragraph breaks
    .replace(/\s*\n\s*/g, " "); // collapse line breaks inside paragraphs
}

async function nextPage() {
  if (!validateCurrentPage()) return;

  saveCurrentEvaluation();

  if (currentPage.value === fixedGroups.value.length - 1) {
    saveOverallEvaluation();
    await saveCurrentDmpEvaluation();

    if (isLastPageAndLastDmp.value) {
      try {
        const response = await $fetch("/api/dmp/complete-survey", { method: "POST" });
        if ("error" in response) {
          toast.add({
            title: 'Error',
            description: response.error,
            color: 'warning',
          });
        }
      } catch (error) {
        toast.add({
          title: 'Error',
          description: 'API request failed.',
          color: 'error',
        });
      }
      router.push("/app/thank-you");
    } else {
      dmpIndex.value++;
      currentPage.value = 0;
      router.push("/app/preview");
    }
  } else {
    currentPage.value++;
  }
}

function prevPage() {
  if (currentPage.value === 0) {
    saveCurrentEvaluation();
    router.push("/app/preview");
  } else {
    currentPage.value--;
  }
}

function flattenedIndex(groupIndex: number, subIndex: number): number {
  let index = 0;

  // Count all sub-elements from previous pages
  for (let p = 0; p < currentPage.value; p++) {
    for (const group of fixedGroups.value[p]) {
      index += group.group.length;
    }
  }

  // Add sub-elements before current subEl in current page
  for (let g = 0; g < groupIndex; g++) {
    index += currentElements.value[g].group.length;
  }

  // Add offset within current group
  index += subIndex;

  return index;
}

const isLastPageAndLastDmp = computed(
  () =>
    currentPage.value === fixedGroups.value.length - 1 &&
    dmpIndex.value === assignedDmps.value.length - 1,
);

function handleErrorSelectionChange(pageIndex, groupIndex, newSelection) {
  const previousSelection = evaluations.value[pageIndex][groupIndex].selectedErrors || [];
  const hasNone = newSelection.includes("None--No errors seen");
  const previouslyHadNone = previousSelection.includes("None--No errors seen");
  
  if (hasNone && !previouslyHadNone) {
    // "None" was just selected, clear all other selections
    evaluations.value[pageIndex][groupIndex].selectedErrors = ["None--No errors seen"];
  } else if (!hasNone && previouslyHadNone) {
    // "None" was deselected, keep other selections
    evaluations.value[pageIndex][groupIndex].selectedErrors = newSelection;
  } else if (hasNone && newSelection.length > 1) {
    // "None" is selected along with others, keep only "None"
    evaluations.value[pageIndex][groupIndex].selectedErrors = ["None--No errors seen"];
  } else {
    // Normal selection without "None"
    evaluations.value[pageIndex][groupIndex].selectedErrors = newSelection;
  }
}

async function saveCurrentDmpEvaluation() {
  try {
    const index = dmpIndex.value;

    saveCurrentEvaluation();
    saveOverallEvaluation();

    const dmpName = assignedDmps.value[index];
    const dmpEvals = evaluationsPerDmp.value[index] || [];

    // dmpEvals is [page][group][evaluation], fixedGroups is [page][group]
    const evalArray = dmpEvals.flatMap((pageGroups, pageIndex) =>
      pageGroups.map((ev, groupIndex) => ({
        elementTitle: fixedGroups.value[pageIndex][groupIndex]?.title || "",
        satisfactionScore: ev.satisfactionScore ?? null,
        selectedErrors: ev.selectedErrors ?? [],
        additionalComments: ev.additionalComments ?? null,
      })),
    );

    const payload = {
      participantId: participantId.value?.toString(),
      dmpEvaluations: [
        {
          dmpName,
          evaluations: evalArray,
          overallAuthorshipGuess:
            overallEvaluationsPerDmp.value[index]?.authorship ?? null,
          overallSatisfaction:
            overallEvaluationsPerDmp.value[index]?.satisfaction ?? null,
        },
      ],
    };

    await $fetch("/api/dmp/save-evaluation", {
      method: "POST",
      body: payload,
    });
  } catch (error) {
    console.error("Save failed:", error);
  }
}
</script>

<template>
  <div v-if="currentElements.length" class="mt-10 space-y-6">
    <div class="mb-4 text-lg text-gray-700">
      <strong
        >DMP #{{ currentDmpIndex + 1 }} – Section-wise Evaluation ({{
          currentPage + 1
        }}/3)</strong
      >
    </div>

    <h1>
      Evaluate each of the sections of the DMP below. The text from each section
      is provided again to facilitate your evaluation.
    </h1>

    <UCard
      v-for="(group, groupIndex) in currentElements"
      :key="groupIndex"
      class="bg-gray-50 bg-white p-4"
    >
      <div v-if="evaluations[currentPage]?.[groupIndex]" class="flex gap-6">
        <div class="w-1/2">
          <h3 class="mb-2 text-xl font-bold text-gray-800">
            {{ group.title }}
          </h3>

          <div
            v-for="(subEl, subIndex) in group.group"
            :key="subIndex"
            class="mb-4"
          >
            <div class="text-base font-bold text-gray-800">
              {{ subEl.subtitle }}
            </div>

            <div class="mb-2 text-sm text-gray-700 italic">
              ({{ helpTexts[flattenedIndex(groupIndex, subIndex)] }})
            </div>

            <div>
              <div class="text-base whitespace-pre-wrap">
                {{ subEl.content }}
              </div>
            </div>
          </div>
        </div>

        <div class="w-1/2 space-y-4">
          <div class="flex flex-col space-y-2 w-full">
            <label class="font-semibold flex">
              <span class="mr-2 flex-shrink-0">1.</span>
              <span class="flex-1">
                How satisfied are you with the response to this Element?
                <span class="text-red-500">*</span>
              </span>
            </label>

            <USelect
              v-model="evaluations[currentPage][groupIndex].satisfactionScore"
              :items="scoreOptions"
              class="w-96"
            />
          </div>

          <div>
            <label class="font-semibold flex">
              <span class="mr-2 flex-shrink-0">2.</span>
              <span class="flex-1">
                What type of errors did you find, if any (select all that
                apply)?
                <span class="text-red-500">*</span>
              </span>
            </label>

            <div class="flex items-start gap-x-4">
              <USelect
                :model-value="evaluations[currentPage][groupIndex].selectedErrors"
                @update:model-value="(value) => handleErrorSelectionChange(currentPage, groupIndex, value)"
                :items="errorTypes"
                multiple
                placeholder="Select error types"
                class="w-190"
                :ui="{
                  // when the item is selected
                  item: 'data-[state=checked]:bg-blue-100 data-[state=checked]:text-blue-800 aria-selected:bg-blue-100 aria-selected:text-blue-800',
                  // ensure the label inherits the color too
                  itemLabel: 'data-[state=checked]:text-blue-800 aria-selected:text-blue-800',
                  content: 'max-h-[400px] overflow-y-auto'
                }"
              />
            </div>
          </div>

          <div>
            <label class="font-semibold flex">
              <span class="mr-2 flex-shrink-0">3.</span>
              <span class="flex-1">
                Provide additional comments (optional):
              </span>
            </label>

            <UTextarea
              v-model="evaluations[currentPage][groupIndex].additionalComments"
              class="w-full"
            />
          </div>
        </div>
      </div>
    </UCard>

    <UCard
      v-if="currentPage === 2"
      class="space-y-8 bg-gray-50 bg-white px-2 pt-6"
    >
      <div class="mb-4 text-center text-xl font-bold">Overall Evaluation</div>
      <p class="text-base mb-6">Provide an overall evaluation of this DMP below.</p>
      <!-- Question 1 -->
      <div class="mb-6 flex gap-x-8">
        <div class="w-1/2">
          <label class="font-semibold flex">
            <span class="mr-2 flex-shrink-0">1.</span>
            <span class="flex-1">
              How satisfied were you with this DMP as a whole?
              <span class="text-red-500">*</span>
            </span>
          </label>
        </div>

        <div class="w-1/2">
          <USelect
            v-model="overallSatisfaction"
            :items="[
              { label: 'Very Dissatisfied', value: 1 },
              { label: 'Dissatisfied', value: 2 },
              { label: 'Neither dissatisfied or satisfied', value: 3 },
              { label: 'Satisfied', value: 4 },
              { label: 'Very Satisfied', value: 5 },
            ]"
            placeholder="Select satisfaction level"
            class="w-96"
          />
        </div>
      </div>

      <!-- Question 2 -->
      <div class="flex gap-x-8">
        <div class="w-1/2">
          <label class="font-semibold flex">
            <span class="mr-2 flex-shrink-0">2.</span>
            <span class="flex-1">
              If you had to guess, would you think this DMP was more likely to
              have been written by a human or by an LLM?
              <span class="text-red-500">*</span>
            </span>
          </label>
        </div>

        <div class="w-1/2">
          <USelect
            v-model="overallAuthorshipGuess"
            :items="[
              { label: 'Human', value: 'Human' },
              { label: 'LLM', value: 'LLM' },
            ]"
            placeholder="Select one"
            class="w-96"
          />
        </div>
      </div>
    </UCard>

    <div class="mt-6 mb-6 flex items-center justify-between">
      <UButton
        icon="i-lucide-arrow-left"
        size="xl"
        color="primary"
        class="flex w-30 items-center justify-center"
        @click="prevPage"
      >
        Previous
      </UButton>

      <UButton
        :trailing-icon="isLastPageAndLastDmp ? '' : 'i-lucide-arrow-right'"
        size="xl"
        color="primary"
        class="flex w-30 items-center justify-center"
        @click="nextPage"
      >
        {{ isLastPageAndLastDmp ? "Complete" : "Next" }}
      </UButton>
    </div>
  </div>
</template>
